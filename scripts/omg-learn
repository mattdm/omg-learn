#!/usr/bin/env python3
"""
omg-learn - Pattern management CLI for omg-learn skill.

A stand-alone script for managing mistake prevention patterns.
No external dependencies except Python 3.6+.
"""

import argparse
import json
import os
import re
import shutil
import subprocess
import sys
import zipfile
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple


# ============================================================================
# ANSI Colors and Display
# ============================================================================

class Colors:
    """ANSI color codes."""
    RESET = '\033[0m'
    BOLD = '\033[1m'
    GREEN = '\033[32m'
    RED = '\033[31m'
    YELLOW = '\033[33m'
    CYAN = '\033[36m'
    DIM = '\033[2m'


def supports_color() -> bool:
    """Check if terminal supports color."""
    if not hasattr(sys.stdout, 'isatty') or not sys.stdout.isatty():
        return False
    if os.environ.get('NO_COLOR') or os.environ.get('TERM') == 'dumb':
        return False
    return True


USE_COLOR = supports_color()


def colored(text: str, color: str) -> str:
    """Apply color if supported."""
    return f"{color}{text}{Colors.RESET}" if USE_COLOR else text


def success(text: str) -> str:
    return colored(text, Colors.GREEN)


def error(text: str) -> str:
    return colored(text, Colors.RED)


def warning(text: str) -> str:
    return colored(text, Colors.YELLOW)


def info(text: str) -> str:
    return colored(text, Colors.CYAN)


def bold(text: str) -> str:
    return colored(text, Colors.BOLD)


def print_separator(char: str = "‚îÄ", width: int = 60):
    """Print a separator line."""
    print(char * width)


def print_success(msg: str):
    print(success("‚úì ") + msg)


def print_error(msg: str):
    print(error("‚úó ") + msg, file=sys.stderr)


def print_warning(msg: str):
    print(warning("‚ö† ") + msg)


def print_info(msg: str):
    print(info("‚Ñπ ") + msg)


def print_table(headers: List[str], rows: List[List[str]]):
    """Print a formatted table."""
    if not rows:
        print("(empty)")
        return

    # Calculate column widths
    col_widths = [len(h) for h in headers]
    for row in rows:
        for i, cell in enumerate(row):
            if i < len(col_widths):
                col_widths[i] = max(col_widths[i], len(str(cell)))

    # Print table
    print("‚îå" + "‚î¨".join("‚îÄ" * (w + 2) for w in col_widths) + "‚îê")

    # Headers
    header_cells = [f" {bold(h).ljust(w)} " for h, w in zip(headers, col_widths)]
    print("‚îÇ" + "‚îÇ".join(header_cells) + "‚îÇ")

    print("‚îú" + "‚îº".join("‚îÄ" * (w + 2) for w in col_widths) + "‚î§")

    # Rows
    for row in rows:
        row_cells = [f" {str(cell).ljust(w)} " for cell, w in zip(row, col_widths)]
        print("‚îÇ" + "‚îÇ".join(row_cells) + "‚îÇ")

    print("‚îî" + "‚î¥".join("‚îÄ" * (w + 2) for w in col_widths) + "‚îò")


# ============================================================================
# JSON Utilities
# ============================================================================

def read_json_file(file_path: str) -> Dict[str, Any]:
    """Read JSON file, return empty dict if not found."""
    path = Path(file_path).expanduser()
    if not path.exists():
        return {}
    try:
        with open(path, 'r') as f:
            return json.load(f)
    except:
        return {}


def write_json_file(file_path: str, data: Dict[str, Any]) -> bool:
    """Write JSON file atomically."""
    path = Path(file_path).expanduser()
    path.parent.mkdir(parents=True, exist_ok=True)

    temp_path = path.with_suffix('.tmp')
    try:
        with open(temp_path, 'w') as f:
            json.dump(data, f, indent=2)
            f.write('\n')
        temp_path.replace(path)
        return True
    except Exception as e:
        print_error(f"Error writing {file_path}: {e}")
        if temp_path.exists():
            temp_path.unlink()
        return False


def merge_patterns(global_file: str, local_file: str) -> List[Dict]:
    """Merge global and local patterns, local overrides global by ID."""
    global_data = read_json_file(global_file)
    local_data = read_json_file(local_file)

    patterns_by_id = {}
    for p in global_data.get('patterns', []):
        if 'id' in p:
            patterns_by_id[p['id']] = p
    for p in local_data.get('patterns', []):
        if 'id' in p:
            patterns_by_id[p['id']] = p

    return list(patterns_by_id.values())


# ============================================================================
# Pattern Manager
# ============================================================================

class PatternManager:
    """Manages patterns across global and project-local scopes."""

    def __init__(self, platform: str = 'claude'):
        self.platform = platform
        home = Path.home()

        # Support multiple directory conventions
        if platform == 'claude':
            # Try .claude first, then fall back to .agents/.agent
            global_candidates = [
                home / '.claude' / 'omg-learn-patterns.json',
                home / '.agents' / 'omg-learn-patterns.json',
                home / '.agent' / 'omg-learn-patterns.json',
            ]
            local_candidates = [
                Path('.claude') / 'omg-learn-patterns.json',
                Path('.agents') / 'omg-learn-patterns.json',
                Path('.agent') / 'omg-learn-patterns.json',
            ]
        else:  # cursor
            global_candidates = [
                home / '.cursor' / 'omg-learn-patterns.json',
                home / '.agents' / 'omg-learn-patterns.json',
                home / '.agent' / 'omg-learn-patterns.json',
            ]
            local_candidates = [
                Path('.cursor') / 'omg-learn-patterns.json',
                Path('.agents') / 'omg-learn-patterns.json',
                Path('.agent') / 'omg-learn-patterns.json',
            ]
        
        # Use first existing file, or first candidate if none exist
        self.global_file = next((f for f in global_candidates if f.exists()), global_candidates[0])
        self.local_file = next((f for f in local_candidates if f.exists()), local_candidates[0])

    def list_patterns(self, scope='all', enabled_only=False) -> List[Dict]:
        """List patterns with metadata."""
        patterns = []

        if scope in ('all', 'global'):
            for p in read_json_file(str(self.global_file)).get('patterns', []):
                p['_scope'] = 'global'
                patterns.append(p)

        if scope in ('all', 'local'):
            for p in read_json_file(str(self.local_file)).get('patterns', []):
                p['_scope'] = 'local'
                patterns.append(p)

        # Remove duplicates (local overrides global)
        if scope == 'all':
            seen = set()
            unique = []
            for p in [p for p in patterns if p.get('_scope') == 'local']:
                pid = p.get('id')
                if pid and pid not in seen:
                    seen.add(pid)
                    unique.append(p)
            for p in [p for p in patterns if p.get('_scope') == 'global']:
                pid = p.get('id')
                if pid and pid not in seen:
                    seen.add(pid)
                    unique.append(p)
            patterns = unique

        if enabled_only:
            patterns = [p for p in patterns if p.get('enabled', True)]

        return patterns

    def get_pattern(self, pattern_id: str) -> Optional[Tuple[Dict, str]]:
        """Get pattern by ID, returns (pattern, scope) or None."""
        # Check local first
        for p in read_json_file(str(self.local_file)).get('patterns', []):
            if p.get('id') == pattern_id:
                return (p, 'local')
        # Check global
        for p in read_json_file(str(self.global_file)).get('patterns', []):
            if p.get('id') == pattern_id:
                return (p, 'global')
        return None

    def _update_pattern_in_file(self, file_path: Path, pattern_id: str, updates: Dict) -> bool:
        """Update pattern in file."""
        data = read_json_file(str(file_path))
        patterns = data.get('patterns', [])

        for p in patterns:
            if p.get('id') == pattern_id:
                p.update(updates)
                return write_json_file(str(file_path), data)
        return False

    def enable_pattern(self, pattern_id: str, scope: Optional[str] = None) -> bool:
        """Enable a pattern."""
        if not scope:
            result = self.get_pattern(pattern_id)
            if not result:
                return False
            _, scope = result

        file_path = self.global_file if scope == 'global' else self.local_file
        return self._update_pattern_in_file(file_path, pattern_id, {'enabled': True})

    def disable_pattern(self, pattern_id: str, scope: Optional[str] = None) -> bool:
        """Disable a pattern."""
        if not scope:
            result = self.get_pattern(pattern_id)
            if not result:
                return False
            _, scope = result

        file_path = self.global_file if scope == 'global' else self.local_file
        return self._update_pattern_in_file(file_path, pattern_id, {'enabled': False})


# ============================================================================
# Pattern Tester
# ============================================================================

class PatternTester:
    """Tests patterns and simulates hook execution."""

    def __init__(self, pm: PatternManager):
        self.pm = pm

    def test_pattern(self, pattern_id: str, test_input: str, tool_name: str = 'Bash') -> Tuple[bool, str, str]:
        """Test if pattern matches input. Returns (matched, action, message)."""
        result = self.pm.get_pattern(pattern_id)
        if not result:
            return (False, '', f"Pattern '{pattern_id}' not found")

        pattern, scope = result

        if not pattern.get('enabled', True):
            return (False, '', "Pattern is disabled")

        # Check hook type
        hook_type = pattern.get('hook', '')
        if hook_type not in ('PreToolUse', 'beforeShellExecution', 'UserPromptSubmit', 'beforeSubmitPrompt'):
            return (False, '', f"Invalid hook type: {hook_type}")

        # Check matcher
        if hook_type in ('PreToolUse', 'beforeShellExecution'):
            matcher = pattern.get('matcher', '')
            if matcher and matcher != '*' and matcher != tool_name:
                return (False, '', f"Matcher '{matcher}' != '{tool_name}'")

        # Check script
        check_script = pattern.get('check_script', '')
        if check_script and Path(check_script).exists():
            try:
                result = subprocess.run([check_script, test_input], capture_output=True, timeout=5)
                if result.returncode != 0:
                    return (True, pattern.get('action', 'warn'), pattern.get('message', 'Matched'))
                return (False, '', "Check script returned 0")
            except:
                return (False, '', "Error running check script")

        # Check regex
        pattern_regex = pattern.get('pattern', '')
        if not pattern_regex:
            return (False, '', "No pattern or check script")

        try:
            flags = re.IGNORECASE if 'Prompt' in hook_type or 'prompt' in hook_type else 0
            if re.search(pattern_regex, test_input, flags):
                exclude = pattern.get('exclude_pattern', '')
                if exclude and re.search(exclude, test_input):
                    return (False, '', f"Excluded by: {exclude}")
                return (True, pattern.get('action', 'warn'), pattern.get('message', 'Matched'))
            return (False, '', "Pattern did not match")
        except re.error as e:
            return (False, '', f"Invalid regex: {e}")

    def simulate_command(self, command: str, tool_name: str = 'Bash') -> Dict[str, Any]:
        """Simulate what hooks would do."""
        patterns = self.pm.list_patterns(scope='all', enabled_only=True)

        hook_type = 'PreToolUse' if self.pm.platform == 'claude' else 'beforeShellExecution'
        relevant = [p for p in patterns if p.get('hook') in (hook_type, 'PreToolUse', 'beforeShellExecution')]

        results = []
        for pattern in relevant:
            pattern_id = pattern.get('id', '')
            matched, action, message = self.test_pattern(pattern_id, command, tool_name)
            if matched:
                results.append({
                    'pattern_id': pattern_id,
                    'action': action,
                    'message': message
                })

        first_match = results[0] if results else None

        return {
            'command': command,
            'patterns_checked': len(relevant),
            'patterns_matched': results,
            'first_match': first_match,
            'would_block': first_match and first_match['action'] == 'block'
        }


# ============================================================================
# Commands
# ============================================================================

def cmd_list(args, pm):
    """List patterns."""
    patterns = pm.list_patterns(scope=args.scope, enabled_only=args.enabled)

    if not patterns:
        print_info("No patterns found")
        return 0

    headers = ["Pattern ID", "Scope", "Enabled", "Description"]
    rows = []

    for p in patterns:
        pid = p.get('id', '(no id)')
        scope = p.get('_scope', 'unknown')
        enabled = success("‚úì") if p.get('enabled', True) else colored("‚úó", Colors.DIM)
        desc = p.get('description', '(no description)')
        if len(desc) > 50:
            desc = desc[:47] + "..."
        rows.append([pid, scope, enabled, desc])

    print_table(headers, rows)

    total = len(patterns)
    enabled_count = len([p for p in patterns if p.get('enabled', True)])
    print()
    print_info(f"{total} pattern(s) total, {enabled_count} enabled")
    return 0


def cmd_show(args, pm):
    """Show pattern details."""
    result = pm.get_pattern(args.pattern_id)
    if not result:
        print_error(f"Pattern '{args.pattern_id}' not found")
        return 1

    pattern, scope = result
    print(bold(f"Pattern: {pattern.get('id')}"))
    print(f"Description: {pattern.get('description', '(no description)')}")
    print(f"Scope: {scope}")
    print(f"Enabled: {success('yes') if pattern.get('enabled') else error('no')}")
    print()
    print(bold("Configuration:"))
    print(f"  Hook: {pattern.get('hook', 'not specified')}")
    if pattern.get('matcher'):
        print(f"  Matcher: {pattern.get('matcher')}")
    if pattern.get('pattern'):
        print(f"  Pattern: {pattern.get('pattern')}")
    if pattern.get('exclude_pattern'):
        print(f"  Exclude: {pattern.get('exclude_pattern')}")
    if pattern.get('check_script'):
        print(f"  Check Script: {pattern.get('check_script')}")
    print(f"  Action: {pattern.get('action', 'warn')}")
    if pattern.get('message'):
        print(f"  Message: {pattern.get('message')}")
    return 0


def cmd_enable(args, pm):
    """Enable a pattern."""
    if not pm.get_pattern(args.pattern_id):
        print_error(f"Pattern '{args.pattern_id}' not found")
        return 1

    if pm.enable_pattern(args.pattern_id, args.scope):
        print_success(f"Enabled pattern: {args.pattern_id}")
        return 0
    return 1


def cmd_disable(args, pm):
    """Disable a pattern."""
    if not pm.get_pattern(args.pattern_id):
        print_error(f"Pattern '{args.pattern_id}' not found")
        return 1

    if pm.disable_pattern(args.pattern_id, args.scope):
        print_success(f"Disabled pattern: {args.pattern_id}")
        return 0
    return 1


def cmd_test(args, pm):
    """Test a pattern."""
    tester = PatternTester(pm)
    matched, action, message = tester.test_pattern(args.pattern_id, args.input, args.tool)

    print(bold(f"Testing pattern: {args.pattern_id}"))
    print(f"Input: {args.input}")
    print(f"Tool: {args.tool}")
    print_separator()

    if matched:
        print(success("‚úì Pattern WOULD match"))
        print()
        print(f"  Action: {bold(action)}")
        print(f"  Message: {message}")
    else:
        print(warning("‚úó Pattern would NOT match"))
        if message:
            print()
            print(f"  Reason: {message}")
    return 0


def cmd_simulate(args, pm):
    """Simulate hook execution."""
    tester = PatternTester(pm)
    result = tester.simulate_command(args.command, args.tool)

    print(bold(f"Simulating command: {args.command}"))
    print(f"Tool: {args.tool}")
    print_separator()
    print(f"Patterns checked: {result['patterns_checked']}")
    print()

    if result['patterns_matched']:
        print(bold("Patterns that would trigger:"))
        for m in result['patterns_matched']:
            symbol = "üõë" if m['action'] == 'block' else "‚ö†Ô∏è"
            print(f"  {symbol} {m['pattern_id']} ({m['action']})")
            print(f"     {m['message']}")
        print()

    if result['first_match']:
        m = result['first_match']
        if result['would_block']:
            print(error("Result: Command would be BLOCKED"))
        else:
            print(success("Result: Command would be ALLOWED"))
        print(f"By: {m['pattern_id']}")
    else:
        print(success("Result: Command would be ALLOWED"))
        print("No patterns matched")
    return 0


# ============================================================================
# Main
# ============================================================================

def detect_platform():
    """
    Auto-detect platform with symlink awareness.
    
    Supports .claude, .cursor, .agents, .agent directories.
    Follows symlinks to determine actual platform.
    """
    # Check directories in order of preference
    check_paths = [
        Path('.claude'),
        Path('.cursor'),
        Path('.agents'),
        Path('.agent'),
        Path.home() / '.claude',
        Path.home() / '.cursor',
        Path.home() / '.agents',
        Path.home() / '.agent',
    ]
    
    for path in check_paths:
        if path.exists():
            # Resolve symlinks
            real_path = path.resolve()
            
            # Determine platform from directory name
            path_str = str(real_path).lower()
            if '.claude' in path_str or str(path) == '.claude':
                return 'claude'
            elif '.cursor' in path_str or str(path) == '.cursor':
                return 'cursor'
            elif '.agents' in path_str or '.agent' in path_str:
                # For generic dirs, check if claude or cursor exists
                if (Path.home() / '.claude').exists():
                    return 'claude'
                elif (Path.home() / '.cursor').exists():
                    return 'cursor'
    
    # Default to claude if nothing found
    return 'claude'


def main():
    parser = argparse.ArgumentParser(description='omg-learn pattern management CLI')
    parser.add_argument('--platform', choices=['claude', 'cursor'], help='Platform (auto-detected)')
    parser.add_argument('--version', action='version', version='omg-learn 2.0.0')

    subparsers = parser.add_subparsers(dest='command', help='Command')

    # list
    list_parser = subparsers.add_parser('list', help='List patterns')
    list_parser.add_argument('--scope', choices=['all', 'global', 'local'], default='all')
    list_parser.add_argument('--enabled', action='store_true')

    # show
    show_parser = subparsers.add_parser('show', help='Show pattern')
    show_parser.add_argument('pattern_id')

    # enable
    enable_parser = subparsers.add_parser('enable', help='Enable pattern')
    enable_parser.add_argument('pattern_id')
    enable_parser.add_argument('--scope', choices=['global', 'local'])

    # disable
    disable_parser = subparsers.add_parser('disable', help='Disable pattern')
    disable_parser.add_argument('pattern_id')
    disable_parser.add_argument('--scope', choices=['global', 'local'])

    # test
    test_parser = subparsers.add_parser('test', help='Test pattern')
    test_parser.add_argument('pattern_id')
    test_parser.add_argument('input')
    test_parser.add_argument('--tool', default='Bash', choices=['Bash', 'Write', 'Edit'])

    # simulate
    sim_parser = subparsers.add_parser('simulate', help='Simulate hooks')
    sim_parser.add_argument('command')
    sim_parser.add_argument('--tool', default='Bash', choices=['Bash', 'Write', 'Edit'])

    args = parser.parse_args()

    if not args.platform:
        args.platform = detect_platform()

    pm = PatternManager(args.platform)

    if args.command == 'list':
        return cmd_list(args, pm)
    elif args.command == 'show':
        return cmd_show(args, pm)
    elif args.command == 'enable':
        return cmd_enable(args, pm)
    elif args.command == 'disable':
        return cmd_disable(args, pm)
    elif args.command == 'test':
        return cmd_test(args, pm)
    elif args.command == 'simulate':
        return cmd_simulate(args, pm)
    else:
        parser.print_help()
        return 1


if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print()
        print_warning("Interrupted")
        sys.exit(130)
    except Exception as e:
        print_error(f"Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
